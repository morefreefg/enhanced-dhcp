#!/bin/sh

# Enhanced DHCP API Backend - Maximum Compatibility Version
# Uses only basic Linux commands - no UCI/LuCI dependencies
# Compatible with all OpenWrt versions

# Set HTTP headers
echo "Content-Type: application/json"
echo "Cache-Control: no-cache"
echo ""

# Configuration files
DHCP_CONFIG="/etc/config/dhcp"
DHCP_LEASES="/var/dhcp.leases"
ARP_TABLE="/proc/net/arp"

# Helper functions
log_message() {
    logger -t enhanced-dhcp-api "$1"
}

# JSON response helpers
json_success() {
    local data="$1"
    echo "{\"success\":true,\"data\":$data}"
}

json_error() {
    local message="$1"
    echo "{\"success\":false,\"error\":\"$message\"}"
}

# Simple config parser using basic shell commands
parse_dhcp_hosts_simple() {
    local config_file="$DHCP_CONFIG"
    local json_array="["
    local first=true
    local in_host=false
    local host_name=""
    local host_mac=""
    local host_ip=""
    local host_tag=""
    
    if [ ! -f "$config_file" ]; then
        echo "[]"
        return
    fi
    
    while IFS= read -r line; do
        # Remove leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        
        case "$line" in
            "config host"*)
                # Start of new host section
                if [ "$in_host" = true ] && [ -n "$host_mac" ]; then
                    # Output previous host
                    if [ "$first" = true ]; then
                        first=false
                    else
                        json_array="$json_array,"
                    fi
                    
                    # Use defaults if empty
                    [ -z "$host_name" ] && host_name="Unknown"
                    [ -z "$host_ip" ] && host_ip="Auto"
                    [ -z "$host_tag" ] && host_tag="default"
                    
                    json_array="$json_array{\"mac\":\"$host_mac\",\"name\":\"$host_name\",\"ip\":\"$host_ip\",\"tag\":\"$host_tag\"}"
                fi
                
                # Reset for new host
                in_host=true
                host_name=""
                host_mac=""
                host_ip=""
                host_tag=""
                ;;
            "config "*|"")
                # End of host section
                if [ "$in_host" = true ] && [ -n "$host_mac" ]; then
                    # Output current host
                    if [ "$first" = true ]; then
                        first=false
                    else
                        json_array="$json_array,"
                    fi
                    
                    # Use defaults if empty
                    [ -z "$host_name" ] && host_name="Unknown"
                    [ -z "$host_ip" ] && host_ip="Auto"
                    [ -z "$host_tag" ] && host_tag="default"
                    
                    json_array="$json_array{\"mac\":\"$host_mac\",\"name\":\"$host_name\",\"ip\":\"$host_ip\",\"tag\":\"$host_tag\"}"
                fi
                in_host=false
                ;;
            *"option name"*)
                if [ "$in_host" = true ]; then
                    host_name=$(echo "$line" | sed "s/.*option name[[:space:]]*['\"][[:space:]]*//; s/[[:space:]]*['\"].*//")
                fi
                ;;
            *"list mac"*)
                if [ "$in_host" = true ]; then
                    host_mac=$(echo "$line" | sed "s/.*list mac[[:space:]]*['\"][[:space:]]*//; s/[[:space:]]*['\"].*//")
                fi
                ;;
            *"option ip"*)
                if [ "$in_host" = true ]; then
                    host_ip=$(echo "$line" | sed "s/.*option ip[[:space:]]*['\"][[:space:]]*//; s/[[:space:]]*['\"].*//")
                fi
                ;;
            *"list tag"*)
                if [ "$in_host" = true ]; then
                    host_tag=$(echo "$line" | sed "s/.*list tag[[:space:]]*['\"][[:space:]]*//; s/[[:space:]]*['\"].*//")
                fi
                ;;
        esac
    done < "$config_file"
    
    # Handle last host if file doesn't end with empty line/config
    if [ "$in_host" = true ] && [ -n "$host_mac" ]; then
        if [ "$first" = true ]; then
            first=false
        else
            json_array="$json_array,"
        fi
        
        # Use defaults if empty
        [ -z "$host_name" ] && host_name="Unknown"
        [ -z "$host_ip" ] && host_ip="Auto"
        [ -z "$host_tag" ] && host_tag="default"
        
        json_array="$json_array{\"mac\":\"$host_mac\",\"name\":\"$host_name\",\"ip\":\"$host_ip\",\"tag\":\"$host_tag\"}"
    fi
    
    json_array="$json_array]"
    echo "$json_array"
}

# Get DHCP hosts using simple parser
get_dhcp_hosts() {
    parse_dhcp_hosts_simple
}

# Simple tags parser
parse_dhcp_tags_simple() {
    local config_file="$DHCP_CONFIG"
    local json_array="["
    local first=true
    local in_tag=false
    local tag_name=""
    local tag_gateway=""
    local tag_dns=""
    
    if [ ! -f "$config_file" ]; then
        echo "[]"
        return
    fi
    
    while IFS= read -r line; do
        # Remove leading/trailing whitespace
        line=$(echo "$line" | sed 's/^[[:space:]]*//; s/[[:space:]]*$//')
        
        case "$line" in
            "config tag "*)
                # Start of new tag section
                if [ "$in_tag" = true ] && [ -n "$tag_name" ]; then
                    # Output previous tag
                    if [ "$first" = true ]; then
                        first=false
                    else
                        json_array="$json_array,"
                    fi
                    
                    json_array="$json_array{\"name\":\"$tag_name\",\"description\":\"\",\"gateway\":\"$tag_gateway\",\"dns\":\"$tag_dns\"}"
                fi
                
                # Extract tag name
                tag_name=$(echo "$line" | sed "s/config tag[[:space:]]*['\"][[:space:]]*//; s/[[:space:]]*['\"].*//")
                in_tag=true
                tag_gateway=""
                tag_dns=""
                ;;
            "config "*|"")
                # End of tag section
                if [ "$in_tag" = true ] && [ -n "$tag_name" ]; then
                    # Output current tag
                    if [ "$first" = true ]; then
                        first=false
                    else
                        json_array="$json_array,"
                    fi
                    
                    json_array="$json_array{\"name\":\"$tag_name\",\"description\":\"\",\"gateway\":\"$tag_gateway\",\"dns\":\"$tag_dns\"}"
                fi
                in_tag=false
                ;;
            *"list dhcp_option"*)
                if [ "$in_tag" = true ]; then
                    option_value=$(echo "$line" | sed "s/.*list dhcp_option[[:space:]]*['\"][[:space:]]*//; s/[[:space:]]*['\"].*//")
                    case "$option_value" in
                        3,*)
                            tag_gateway="${option_value#3,}"
                            ;;
                        6,*)
                            tag_dns="${option_value#6,}"
                            ;;
                    esac
                fi
                ;;
        esac
    done < "$config_file"
    
    # Handle last tag if file doesn't end with empty line/config
    if [ "$in_tag" = true ] && [ -n "$tag_name" ]; then
        if [ "$first" = true ]; then
            first=false
        else
            json_array="$json_array,"
        fi
        
        json_array="$json_array{\"name\":\"$tag_name\",\"description\":\"\",\"gateway\":\"$tag_gateway\",\"dns\":\"$tag_dns\"}"
    fi
    
    json_array="$json_array]"
    echo "$json_array"
}

# Get DHCP tags using simple parser
get_dhcp_tags() {
    parse_dhcp_tags_simple
}

# Parse DHCP leases file
parse_dhcp_leases() {
    local json_array="["
    local first=true
    
    if [ -f "$DHCP_LEASES" ] && [ -s "$DHCP_LEASES" ]; then
        while IFS= read -r line; do
            # Parse lease line: timestamp mac ip hostname
            set -- $line
            if [ $# -ge 4 ]; then
                local timestamp="$1"
                local macaddr="$2"
                local ipaddr="$3"
                local hostname="$4"
                
                # Handle unknown hostname
                [ "$hostname" = "*" ] && hostname="Unknown"
                
                # Build JSON object
                if [ "$first" = true ]; then
                    first=false
                else
                    json_array="$json_array,"
                fi
                
                json_array="$json_array{\"timestamp\":\"$timestamp\",\"macaddr\":\"$macaddr\",\"ipaddr\":\"$ipaddr\",\"hostname\":\"$hostname\"}"
            fi
        done < "$DHCP_LEASES"
    fi
    
    json_array="$json_array]"
    echo "$json_array"
}

# Get ARP table entries
parse_arp_table() {
    local json_array="["
    local first=true
    
    if [ -f "$ARP_TABLE" ]; then
        # Skip header line and parse entries
        tail -n +2 "$ARP_TABLE" | while IFS= read -r line; do
            set -- $line
            if [ $# -ge 4 ]; then
                local ipaddr="$1"
                local macaddr="$4"
                local device="$6"
                
                # Skip incomplete entries
                [ "$macaddr" = "00:00:00:00:00:00" ] && continue
                
                # Build JSON object
                if [ "$first" = true ]; then
                    first=false
                else
                    json_array="$json_array,"
                fi
                
                json_array="$json_array{\"ipaddr\":\"$ipaddr\",\"macaddr\":\"$macaddr\",\"device\":\"$device\"}"
            fi
        done
    fi
    
    json_array="$json_array]"
    echo "$json_array"
}

# Get combined device information - simplified version
get_devices() {
    local json_array="["
    local first=true
    local temp_file="/tmp/enhanced_dhcp_devices.$$"
    
    # Start with static hosts
    get_dhcp_hosts | sed 's/^\[//; s/\]$//; s/},{/}\
{/g' | while IFS= read -r host_json; do
        if [ -n "$host_json" ] && [ "$host_json" != "{" ] && [ "$host_json" != "}" ]; then
            # Add type and has_config fields to static hosts
            echo "${host_json%\}},\"type\":\"static\",\"has_config\":true}"
        fi
    done > "$temp_file"
    
    # Add ARP devices that aren't in static hosts
    if [ -f "$ARP_TABLE" ]; then
        tail -n +2 "$ARP_TABLE" | while IFS= read -r line; do
            set -- $line
            if [ $# -ge 4 ]; then
                local ipaddr="$1"
                local macaddr="$4"
                
                [ "$macaddr" = "00:00:00:00:00:00" ] && continue
                
                # Check if MAC already exists in static hosts
                if ! grep -q "\"$macaddr\"" "$temp_file" 2>/dev/null; then
                    echo "{\"mac\":\"$macaddr\",\"name\":\"Unknown\",\"ip\":\"$ipaddr\",\"tag\":\"default\",\"type\":\"arp\",\"has_config\":false}"
                fi
            fi
        done >> "$temp_file"
    fi
    
    # Output combined results
    if [ -s "$temp_file" ]; then
        json_array="["
        first=true
        while IFS= read -r device_json; do
            if [ -n "$device_json" ]; then
                if [ "$first" = true ]; then
                    first=false
                else
                    json_array="$json_array,"
                fi
                json_array="$json_array$device_json"
            fi
        done < "$temp_file"
        json_array="$json_array]"
    else
        json_array="[]"
    fi
    
    rm -f "$temp_file"
    echo "$json_array"
}

# Get system statistics
get_stats() {
    local total_tags=0
    local total_devices=0
    local online_devices=0
    
    # Count tags using grep
    if [ -f "$DHCP_CONFIG" ]; then
        total_tags=$(grep -c "^config tag" "$DHCP_CONFIG" 2>/dev/null || echo 0)
        total_devices=$(grep -c "^config host" "$DHCP_CONFIG" 2>/dev/null || echo 0)
    fi
    
    # Count active leases
    if [ -f "$DHCP_LEASES" ]; then
        online_devices=$(wc -l < "$DHCP_LEASES" 2>/dev/null || echo 0)
    fi
    
    echo "{\"total_tags\":$total_tags,\"total_devices\":$total_devices,\"online_devices\":$online_devices}"
}

# UCI-compatible wrapper for writing configurations
uci_compat_set() {
    local config="$1"
    local path="$2"
    local value="$3"
    
    # For compatibility, try uci first, then fall back to direct editing
    if command -v uci >/dev/null 2>&1; then
        uci set "$config.$path=$value" 2>/dev/null && return 0
    fi
    
    # Fallback: direct file editing (simplified - would need full implementation)
    log_message "Warning: UCI not available, configuration changes not saved"
    return 1
}

# Apply tag to device (basic implementation)
apply_tag() {
    local mac="$1"
    local tag="$2"
    local name="$3"
    
    # Validate MAC address
    if ! echo "$mac" | grep -qE '^([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}$'; then
        json_error "Invalid MAC address format"
        return 1
    fi
    
    # Try UCI if available
    if command -v uci >/dev/null 2>&1; then
        # Remove existing host entry
        uci show dhcp 2>/dev/null | grep "\.mac='$mac'" | cut -d. -f2 | cut -d= -f1 | while read section; do
            uci delete "dhcp.$section" 2>/dev/null
        done
        
        # Add new host entry
        local section_name=$(uci add dhcp host 2>/dev/null)
        if [ -n "$section_name" ]; then
            uci set "dhcp.$section_name.mac=$mac" 2>/dev/null
            uci set "dhcp.$section_name.name=${name:-device_$(echo $mac | tr ':' '')}" 2>/dev/null
            
            if [ "$tag" != "default" ]; then
                uci set "dhcp.$section_name.tag=$tag" 2>/dev/null
            fi
            
            if uci commit dhcp 2>/dev/null; then
                log_message "Applied tag $tag to device $mac ($name)"
                (/etc/init.d/dnsmasq restart >/dev/null 2>&1) &
                json_success '"Device updated successfully"'
                return 0
            fi
        fi
    fi
    
    json_error "Configuration update not supported without UCI"
    return 1
}

# Delete device assignment (remove DHCP host entry)
delete_assignment() {
    local mac="$1"
    
    # Validate MAC address
    if ! echo "$mac" | grep -qE '^([0-9A-Fa-f]{2}[:-]){5}[0-9A-Fa-f]{2}$'; then
        json_error "Invalid MAC address format"
        return 1
    fi
    
    # Try UCI if available
    if command -v uci >/dev/null 2>&1; then
        local deleted=false
        
        # Find and remove host entries with matching MAC
        uci show dhcp 2>/dev/null | grep "\.mac='$mac'" | cut -d. -f2 | cut -d= -f1 | while read section; do
            uci delete "dhcp.$section" 2>/dev/null
            deleted=true
        done
        
        if uci commit dhcp 2>/dev/null; then
            log_message "Deleted DHCP assignment for device $mac"
            (/etc/init.d/dnsmasq restart >/dev/null 2>&1) &
            json_success '"Device assignment deleted successfully"'
            return 0
        fi
    fi
    
    json_error "Configuration update not supported without UCI"
    return 1
}

# Parse request
REQUEST_METHOD="${REQUEST_METHOD:-GET}"
QUERY_STRING="${QUERY_STRING:-}"
PATH_INFO="${PATH_INFO:-}"

# Parse query parameters
parse_query() {
    local query="$1"
    local IFS='&'
    set -- $query
    for param; do
        local key="${param%%=*}"
        local value="${param#*=}"
        # URL decode value (basic implementation)
        value=$(printf '%b' "${value//%/\\x}" 2>/dev/null || echo "$value")
        eval "PARAM_$key=\"\$value\""
    done
}

# Parse POST data
parse_post() {
    if [ "$REQUEST_METHOD" = "POST" ]; then
        local content_length="${CONTENT_LENGTH:-0}"
        if [ "$content_length" -gt 0 ] && [ "$content_length" -lt 1024 ]; then
            read -n "$content_length" POST_DATA 2>/dev/null
            parse_query "$POST_DATA"
        fi
    fi
}

# Main request handler
case "$REQUEST_METHOD" in
    "GET")
        parse_query "$QUERY_STRING"
        
        case "$PATH_INFO" in
            "/leases")
                json_success "$(parse_dhcp_leases)"
                ;;
            "/devices")
                json_success "$(get_devices)"
                ;;
            "/tags")
                json_success "$(get_dhcp_tags)"
                ;;
            "/stats")
                json_success "$(get_stats)"
                ;;
            "/arp")
                json_success "$(parse_arp_table)"
                ;;
            *)
                json_error "Unknown endpoint: $PATH_INFO"
                ;;
        esac
        ;;
    "POST")
        parse_post
        
        case "$PATH_INFO" in
            "/apply_tag")
                if [ -n "$PARAM_mac" ] && [ -n "$PARAM_tag" ]; then
                    apply_tag "$PARAM_mac" "$PARAM_tag" "$PARAM_name"
                else
                    json_error "Missing required parameters: mac, tag"
                fi
                ;;
            "/delete_assignment")
                if [ -n "$PARAM_mac" ]; then
                    delete_assignment "$PARAM_mac"
                else
                    json_error "Missing required parameter: mac"
                fi
                ;;
            *)
                json_error "POST endpoint not implemented: $PATH_INFO"
                ;;
        esac
        ;;
    *)
        json_error "Method not allowed: $REQUEST_METHOD"
        ;;
esac